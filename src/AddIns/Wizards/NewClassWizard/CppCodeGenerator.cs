//
// -*- C# -*-
//
// Author:         Roman Taranchenko
// Copyright:      (c) 2004 Roman Taranchenko
// Copying Policy: GNU General Public License
//
// Some code was borrowed from mono class library ;-)
//
// This implementation of System.CodeDom.Compiler.ICodeGenerator 
// has limited functionality. It designed only for use in 
// the SharpDevelop's class wizard.
//

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections;
using System.IO;
using System.Reflection;

namespace NewClassWizard
{

	public class CppCodeGenerator: CodeGenerator
	{
		
		static CppCodeGenerator()
		{
			keywordsTable = new Hashtable();
			foreach (string keyword in keywords)
			{
				keywordsTable.Add (keyword,keyword);
			}
			typesTable = new Hashtable();
			foreach (string type in types)
			{
				typesTable.Add (type,type);
			}
		}
		
		protected override string NullToken 
		{
			get 
			{
				return "NULL";
			}
		}

		protected override void GenerateArrayCreateExpression(CodeArrayCreateExpression expression)
		{
		}
		
		protected override void GenerateBaseReferenceExpression(CodeBaseReferenceExpression expression)
		{
		}
		
		protected override void GenerateCastExpression(CodeCastExpression expression)
		{
			Output.Write("(__try_cast<");
			OutputType(expression.TargetType);
			Output.Write(">(");
			GenerateExpression(expression.Expression);
			Output.Write("))");
		}


		protected override void GenerateCompileUnitStart(CodeCompileUnit compileUnit)
		{
			GenerateComment(new CodeComment("------------------------------------------------------------------------------"));
			GenerateComment(new CodeComment(" <autogenerated>"));
			GenerateComment(new CodeComment("     This code was generated by a tool."));
			GenerateComment(new CodeComment("     SharpDevelop Version: " + Assembly.GetEntryAssembly().GetName().Version));
			Output.WriteLine();
			GenerateComment(new CodeComment("     Changes to this file may cause incorrect behavior and will be lost if "));
			GenerateComment(new CodeComment("     the code is regenerated."));
			GenerateComment(new CodeComment(" </autogenerated>"));
			GenerateComment(new CodeComment("------------------------------------------------------------------------------"));
			Output.WriteLine();
			Output.WriteLine("#pragma once");
			Output.WriteLine();
			Output.WriteLine("#using <mscorlib.dll>");
			Output.WriteLine();
		}


		protected override void GenerateDelegateCreateExpression(CodeDelegateCreateExpression expression)
		{
		}

		protected override void GenerateFieldReferenceExpression(CodeFieldReferenceExpression expression)
		{
		}
		
		protected override void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression expression)
		{
		}

		protected override void GenerateVariableReferenceExpression(CodeVariableReferenceExpression expression)
		{
		}
			
		protected override void GenerateIndexerExpression(CodeIndexerExpression expression)
		{
		}
		
		protected override void GenerateArrayIndexerExpression(CodeArrayIndexerExpression expression)
		{
		}
		
		protected override void GenerateSnippetExpression(CodeSnippetExpression expression)
		{
		}
		
		protected override void GenerateMethodInvokeExpression(CodeMethodInvokeExpression expression)
		{
		}

		protected override void GenerateMethodReferenceExpression(CodeMethodReferenceExpression expression)
		{
		}

		protected override void GenerateEventReferenceExpression(CodeEventReferenceExpression expression)
		{
		}

		protected override void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression expression)
		{
		}
		
		protected override void GenerateObjectCreateExpression(CodeObjectCreateExpression expression)
		{
		}

		protected override void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression expression)
		{
		}

		protected override void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression expression)
		{
		}

		protected override void GenerateThisReferenceExpression(CodeThisReferenceExpression expression)
		{
		}

		protected override void GenerateExpressionStatement(CodeExpressionStatement statement)
		{
			GenerateExpression(statement.Expression);
			Output.WriteLine(';');
		}

		protected override void GenerateIterationStatement(CodeIterationStatement statement)
		{
		}

		protected override void GenerateThrowExceptionStatement(CodeThrowExceptionStatement statement)
		{
		}

		protected override void GenerateComment(CodeComment comment)
		{
			foreach (string line in comment.Text.Split('\n'))
			{
				Output.Write("// ");
				Output.WriteLine(line);
    		}
		}

		protected override void GenerateMethodReturnStatement(CodeMethodReturnStatement statement)
		{
			if (statement.Expression != null) 
			{
				Output.Write ("return ");
				GenerateExpression(statement.Expression);
				Output.WriteLine(";");
			} 
			else 
			{
				Output.WriteLine("return;");
			}
		}

		protected override void GenerateConditionStatement(CodeConditionStatement statement)
		{
		}

		protected override void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement statement)
		{
		}

		protected override void GenerateAssignStatement(CodeAssignStatement statement)
		{			
			GenerateExpression(statement.Left);
			Output.Write(" = ");
			GenerateExpression(statement.Right);
			Output.WriteLine(';');
		}

		protected override void GenerateAttachEventStatement(CodeAttachEventStatement statement)
		{
		}

		protected override void GenerateRemoveEventStatement(CodeRemoveEventStatement statement)
		{
		}

		protected override void GenerateGotoStatement(CodeGotoStatement statement)
		{
		}
		
		protected override void GenerateLabeledStatement(CodeLabeledStatement statement)
		{
		}

		protected override void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement statement)
		{
			OutputTypeNamePair(statement.Type, GetSafeName(statement.Name));
			CodeExpression initExpression = statement.InitExpression;
			if (initExpression != null)
			{
				Output.Write(" = ");
				GenerateExpression(initExpression);
			}
			Output.WriteLine(';');
		}

		protected override void GenerateLinePragmaStart(CodeLinePragma linePragma)
		{
			Output.WriteLine();
			Output.Write("#line ");
			Output.Write(linePragma.LineNumber);
			Output.Write(" \"");
			Output.Write(linePragma.FileName);
			Output.Write("\"");
			Output.WriteLine();
		}

		protected override void GenerateLinePragmaEnd(CodeLinePragma linePragma)
		{
			Output.WriteLine();
			Output.WriteLine("#line default");
		}

		protected override void GenerateEvent(CodeMemberEvent eventRef, CodeTypeDeclaration declaration)
		{
		}

		protected override void GenerateField(CodeMemberField field)
		{
			MemberAttributes attributes = field.Attributes;
			OutputMemberAccessModifier(attributes);

			if (field.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(field.CustomAttributes);
			}
			
			OutputFieldScopeModifier(attributes);
			OutputTypeNamePair(field.Type, GetSafeName (field.Name));

			CodeExpression initExpression = field.InitExpression;
			if (initExpression != null) 
			{
				Output.Write(" = ");
				GenerateExpression(initExpression);
			}
			if (IsCurrentEnum)
			{
				Output.WriteLine(',');
			}
			else
			{
				Output.WriteLine(';');
			}
		}
		
		protected override void GenerateSnippetMember(CodeSnippetTypeMember member)
		{
		}
		
		protected override void GenerateEntryPointMethod(CodeEntryPointMethod method, CodeTypeDeclaration declaration)
		{
		}
		
		protected override void GenerateMethod(CodeMemberMethod method, CodeTypeDeclaration declaration)
		{
			MemberAttributes attributes = method.Attributes;

			if (method.PrivateImplementationType == null && !declaration.IsInterface)
			{
				OutputMemberAccessModifier(attributes);
			}
			
			if (method.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(method.CustomAttributes);
			}
			
			if (method.ReturnTypeCustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(method.ReturnTypeCustomAttributes);
			}
			
			
			if (!declaration.IsInterface)
			{
				OutputMemberScopeModifier(attributes);
			}
			
			OutputType(method.ReturnType);

			Output.Write(' ');

			CodeTypeReference privateType = method.PrivateImplementationType;
			if (privateType != null) 
			{
				OutputType(privateType);
				Output.Write("::");
			}
			Output.Write(GetSafeName(method.Name));

			Output.Write('(');
			OutputParameters(method.Parameters);
			Output.Write(')');

			if ((attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract || declaration.IsInterface)
			{
				Output.WriteLine(" = 0;");
			}
			else 
			{
				Output.WriteLine(" {");
				++Indent;
				GenerateStatements(method.Statements);
				--Indent;
				Output.WriteLine('}');
			}
		}

		private void OutputPropertyModifier(MemberAttributes attributes)
		{
				OutputMemberAccessModifier(attributes);
				Output.Write("__property ");
				OutputMemberScopeModifier(attributes);
		}
		
		private void OutputPropertyStuff(CodeMemberProperty property, CodeTypeDeclaration declaration)
		{
			Output.Write('(');
			OutputParameters(property.Parameters);
			if (property.HasSet)
			{
				if (property.Parameters.Count > 0)
				{
					Output.Write(", ");
				}
				OutputTypeNamePair(property.Type, "value");
			}
			Output.Write(')');
			if (declaration.IsInterface)
			{
				Output.WriteLine(" = 0");
			}
			else
			{
				Output.WriteLine (" {");
				++Indent;
				GenerateStatements (property.GetStatements);
				--Indent;
				Output.WriteLine ("}");
			}
			Output.WriteLine();
		}
		
		protected override void GenerateProperty(CodeMemberProperty property, CodeTypeDeclaration declaration)
		{
			if (property.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(property.CustomAttributes);
			}
			
			MemberAttributes attributes = property.Attributes;
			
			if (property.HasGet)
			{
				OutputPropertyModifier(attributes);
				OutputTypeNamePair(property.Type, GetSafeName("get_" + property.Name));
				OutputPropertyStuff(property, declaration);
			}
			if (property.HasSet)
			{
				OutputPropertyModifier(attributes);
				Output.Write("void ");
				Output.Write(GetSafeName("set_" + property.Name));
				OutputPropertyStuff(property, declaration);
			}
		}

		protected override void GenerateConstructor(CodeConstructor constructor, CodeTypeDeclaration declaration)
		{
			OutputMemberAccessModifier(constructor.Attributes);
			Output.Write(GetSafeName(CurrentTypeName) + " (");
			OutputParameters(constructor.Parameters);
			Output.Write (") ");
			Output.WriteLine ("{");
			Indent++;
			GenerateStatements(constructor.Statements);
			Indent--;
			Output.WriteLine ('}');
		}
		
		protected override void GenerateTypeConstructor(CodeTypeConstructor constructor)
		{
			Output.WriteLine("static " + GetSafeName(CurrentTypeName) + "() {");
			Indent++;
			GenerateStatements(constructor.Statements);
			Indent--;
			Output.WriteLine('}');
		}

		protected override void GenerateTypeStart(CodeTypeDeclaration declaration)
		{
			CodeTypeDelegate del = declaration as CodeTypeDelegate;

			if (declaration.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(declaration.CustomAttributes);
			}
			
			TypeAttributes attributes = declaration.TypeAttributes;
			OutputTypeAttributes(attributes, declaration.IsStruct, declaration.IsEnum);

			if (del != null) 
			{
				if (del.ReturnType != null)
				{
					OutputType(del.ReturnType);
				}
				else
				{
					Output.Write ("void");
				}
				Output.Write(' ');
			}

			Output.Write(GetSafeName (declaration.Name));

			Output.Write(' ');
			
			IEnumerator enumerator = declaration.BaseTypes.GetEnumerator();
			if (enumerator.MoveNext()) 
			{
				CodeTypeReference type = (CodeTypeReference)enumerator.Current;
			
				Output.Write(": public ");
				OutputSimpleType(type);
				
				while (enumerator.MoveNext()) 
				{
					type = (CodeTypeReference)enumerator.Current;
				
					Output.Write(", public ");
					OutputSimpleType(type);
				}

				Output.Write(' ');
			}
			if (del != null)
			{
				Output.Write ("(");
			}
			else
			{
				Output.WriteLine ("{");
			}
			++Indent;
		}

		protected override void GenerateTypeEnd(CodeTypeDeclaration declaration)
		{
			--Indent;
			if (declaration is CodeTypeDelegate)
				Output.WriteLine (");");
			else
				Output.WriteLine ("};");
		}

		protected override void GenerateNamespaceStart(CodeNamespace ns)
		{
			string name = ns.Name;
			if (name != null && name != "") {
				Output.Write("namespace ");
				Output.Write(GetSafeName (name));
				Output.WriteLine(" {");
				++Indent;
			}
		}

		protected override void GenerateNamespaceEnd(CodeNamespace ns)
		{
			string name = ns.Name;
			if (name != null && name != "") {
				--Indent;
				Output.WriteLine("};");
			}
		}

		protected override void GenerateNamespaceImport(CodeNamespaceImport import)
		{
			Output.Write("using namespace ");
			Output.Write(GetSafeName(import.Namespace));
			Output.WriteLine(';');
		}
		
		protected override void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
		{
			Output.Write('[');
			CodeMemberMethod met = CurrentMember as CodeMemberMethod;
			if (met != null && met.ReturnTypeCustomAttributes == attributes)
			{
				Output.Write ("return: ");
			}
		}
		
		protected override void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
		{
			Output.WriteLine(']');
		}

		protected override void OutputType(CodeTypeReference type)
		{
			Output.Write(GetTypeOutput(type));
		}

		private void OutputSimpleType(CodeTypeReference type)
		{
			Output.Write(GetTypeOutput(type, false));
		}
		
		protected override string QuoteSnippetString(string value)
		{
			return value;
		}

		private void GenerateDeclaration(CodeTypeReference type, string name, CodeExpression initExpression)
		{
			OutputTypeNamePair(type, GetSafeName(name));

			if (initExpression != null) 
			{
				Output.Write(" = ");
				GenerateExpression(initExpression);
			}

			Output.WriteLine(';');
		}
		
		private void GenerateMemberReferenceExpression(CodeExpression targetObject, string memberName)
		{
			if (targetObject != null) 
			{
				GenerateExpression(targetObject);
				Output.Write('.');
			}
			Output.Write(GetSafeName (memberName));
		}
			
		protected override void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
		{
			if (e.CustomAttributes != null && e.CustomAttributes.Count > 0)
			{
				OutputAttributeDeclarations(e.CustomAttributes);
			}
			OutputDirection(e.Direction);
			OutputType(e.Type);
			Output.Write(' ');
			Output.Write(GetSafeName(e.Name));
		}

		/* 
		 * ICodeGenerator
		 */

		protected override string CreateEscapedIdentifier(string value)
		{
			return GetSafeName(value);
		}

		protected override string CreateValidIdentifier(string value)
		{
			if (value == null)
			{
				throw new NullReferenceException();
			}
			if (keywordsTable.Contains(value))
			{
				return "_" + value;
			}
			else
			{
				return value;
			}
		}

		protected override string GetTypeOutput(CodeTypeReference type)
		{
			return GetTypeOutput(type, true);
		}

		private string GetTypeOutput(CodeTypeReference type, bool isReference)
		{
			string result;
			CodeTypeReference arrayType;

			arrayType = type.ArrayElementType;
			if (arrayType != null)
			{
				result = GetTypeOutput(arrayType);
			}
			else 
			{
				switch (type.BaseType)
				{
					case "System.Double":
						result = "double";
						break;
					case "System.Single":
						result = "float";
						break;
					case "System.Byte":
						result = "unsigned char";
						break;
					case "System.SByte":
						result = "char";
						break;
					case "System.Int32":
						result = "int";
						break;
					case "System.UInt32":
						result = "unsigned int";
						break;
					case "System.Int64":
						result = "__int64";
						break;
					case "System.UInt64":
						result = "usigned __int64";
						break;
					case "System.Int16":
						result = "short";
						break;
					case "System.UInt16":
						result = "usigned short";
						break;
					case "System.Boolean":
						result = "bool";
						break;
					case "System.Char":
						result = "char";
						break;
					case "System.String":
						result = "System::String" + (isReference ? "*" : "");
						break;
					case "System.Object":
						result = "System::Object" + (isReference ? "*" : "");
						break;
					case "System.Void":
						result = "void";
						break;
				default:
					result = type.BaseType.Replace(".", "::") + (isReference ? "*" : "");
					break;
				}
			}
			
			result = GetSafeTypeName(result);

			int rank = type.ArrayRank;
			if (rank > 0) {
				result += "[";
				for (--rank; rank > 0; --rank )
					result += ",";
				result += "]";
			}

			return result;
		}

		protected override bool IsValidIdentifier(string identifier)
		{
			return true;
		}

		protected override bool Supports(GeneratorSupport supports)
		{
			return !((supports & GeneratorSupport.Win32Resources) != 0);
		}

		string GetSafeName (string id)
		{
			if (keywordsTable.Contains(id) || typesTable.Contains(id))
			{
				return "__identifier(" + id + ")";
			}
			return id;
		}

		string GetSafeTypeName (string id)
		{
			if (keywordsTable.Contains (id))
			{
				return "__identifier(" + id + ")";
			}
			return id;
		}

		protected override void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum)
		{
			if (isStruct)
			{
				Output.Write("struct ");
			}
			else if (isEnum)
			{
				Output.Write("enum ");
			}
			else 
			{
				if ((attributes & TypeAttributes.Interface) != 0) 
				{
					Output.Write("__interface ");
				}
				else if (IsCurrentDelegate)
				{
					Output.Write("__delegate ");
				}
				else 
				{
					if ((attributes & TypeAttributes.Sealed) != 0)
					{
						Output.Write("__sealed ");
					}
					if ((attributes & TypeAttributes.Abstract) != 0)
					{
						Output.Write("__abstract ");
					}
					Output.Write("__gc class ");
				}
			}
		}
		
		enum AccessModifier {PUBLIC, PROTECTED, PRIVATE, UNKNOWN}
		
		private AccessModifier _lastAccessModifier = AccessModifier.UNKNOWN;
		
		protected override void OutputMemberAccessModifier(MemberAttributes attributes)
		{
			AccessModifier accessModifier = GetAccessModifier(attributes);
			if (accessModifier != _lastAccessModifier)
			{
				_lastAccessModifier = accessModifier;
				switch (_lastAccessModifier)
				{
					case AccessModifier.PRIVATE:
						Output.WriteLine("private:");
						break;
					case AccessModifier.PROTECTED:
						Output.WriteLine("protected:");
						break;
					case AccessModifier.PUBLIC:
						Output.WriteLine("public:");
						break;
				}
				Output.WriteLine();
			}

		}
		
		private AccessModifier GetAccessModifier(MemberAttributes attributes)
		{
			AccessModifier result = AccessModifier.UNKNOWN;
			switch (attributes & MemberAttributes.AccessMask) 
			{
				case MemberAttributes.Private:
					result = AccessModifier.PRIVATE;
					break;
				case MemberAttributes.Family:
					result = AccessModifier.PROTECTED;
					break;
				case MemberAttributes.FamilyOrAssembly:
				case MemberAttributes.Assembly:
				case MemberAttributes.FamilyAndAssembly:
				case MemberAttributes.Public:
					result = AccessModifier.PUBLIC;
					break;
			}
			return result;
		}
		
		protected override void OutputMemberScopeModifier (MemberAttributes attributes)
		{
			switch (attributes & MemberAttributes.ScopeMask) 
			{
				case MemberAttributes.Abstract:
					Output.Write ("virtual ");
					break;
				case MemberAttributes.Final:
					// Do nothing
					break;
				case MemberAttributes.Static:
					Output.Write ("static ");
					break;
				case MemberAttributes.Override:
					Output.Write ("virtual ");
					break;
				default:
					//
					// FUNNY! if the scope value is
					// rubbish (0 or >Const), and access
					// is public or protected, make it
					// "virtual".
					//
					// i'm not sure whether this is 100%
					// correct, but it seems to be MS
					// behavior. 
					//
					MemberAttributes access = attributes & MemberAttributes.AccessMask;
					if (access == MemberAttributes.Public || access == MemberAttributes.Family)
					{
						Output.Write ("virtual ");
					}
					break;
			}
		}
		
		static Hashtable typesTable;
		static string[] types = new string[] {
			"bool","float","int","char","short",
			"double","void","__int8","__int16",
			"__int32","__int64","__wchar_t","wchar_t",
			"__m64","__m128","__m128d","__m128i",
		};

		static Hashtable keywordsTable;
		static string[] keywords = new string[] {
			"__abstract","__alignof","__asm","__assume",
			"__based","__box","__cdecl","__declspec",
			"__delegate","__event","__except","__fastcall", 
			"__finally","__forceinline","__gc","__hook",
			"__identifier","__if_exists","__if_not_exists","__inline",
			"__interface","__leave","__multiple_inheritance","__nogc",
			"__noop","__pin","__property","__raise", 
			"__sealed","__single_inheritance","__stdcall","__super", 
			"__try_cast","__try",
			"__unhook","__uuidof","__value","__virtual_inheritance",
			"__w64","break", 
			"case","catch","class", 
			"const","const_cast","continue","default",
			"delete","deprecated","dllexport","dllimport",
			"do","dynamic_cast","else",
			"enum","explicit","extern","false",
			"for","friend","goto",
			"if","inline",
			"mutable","naked","namespace","new",
			"noinline","noreturn","nothrow","novtable",
			"operator","private","property","protected",
			"public","register","reinterpret_cast","return",
			"selectany","short","signed","sizeof",
			"static","static_cast","struct","switch",
			"template","this","thread","throw",
			"true","try","typedef","typeid",
			"typename","union","unsigned","using",
			"uuid","virtual","volatile",
			"while" 
		};
	}
}
